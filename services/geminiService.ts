import { GoogleGenAI, Content, Modality, Type } from "@google/genai";
import { SYSTEM_INSTRUCTION, LORE_EXTRACTION_SYSTEM_INSTRUCTION, INITIAL_SYSTEM_INSTRUCTION } from '../constants';
import { LoreEntry, NarrativeState } from "../types";

// Ensure API_KEY is available, otherwise this will throw an error which is intended.
if (!process.env.API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// Define a custom error for rate limit issues
export class RateLimitError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'RateLimitError';
  }
}

// This new function is for the very first turn, based on a seed.
export const getInitialGameUpdateStream = (seed: string) => {
  const prompt = `The seed for this universe is: "${seed}". Begin the story.`;

  return ai.models.generateContentStream({
    model: 'gemini-2.5-flash',
    contents: [{ role: 'user', parts: [{ text: prompt }] }],
    config: {
      systemInstruction: INITIAL_SYSTEM_INSTRUCTION,
    }
  });
};

// This function is for text generation and is stateless, taking the full conversation history.
export const getGameUpdateStream = (history: Content[], playerInput: string, narrativeState: NarrativeState) => {
  const stateString = JSON.stringify(narrativeState);
  const playerInputWithState = `Current State: ${stateString}\n\nPlayer Action: ${playerInput}`;
  
  return ai.models.generateContentStream({
    model: 'gemini-2.5-flash',
    // The 'contents' parameter takes the entire conversation history for context.
    contents: [...history, { role: 'user', parts: [{ text: playerInputWithState }] }],
    config: {
      systemInstruction: SYSTEM_INSTRUCTION,
    }
  });
};

// This new function handles image editing/generation.
export const generateSceneImage = async ({ prompt, base64ImageData, mimeType }: { prompt: string; base64ImageData: string; mimeType: string; }) => {
  const imagePart = {
    inlineData: {
      data: base64ImageData,
      mimeType: mimeType,
    },
  };
  const textPart = { text: `Concept: ${prompt}` };

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image-preview',
    contents: { parts: [imagePart, textPart] },
    config: {
      responseModalities: [Modality.IMAGE, Modality.TEXT],
    },
  });

  for (const part of response.candidates[0].content.parts) {
    if (part.inlineData) {
      return part.inlineData.data; // Return the new base64 string
    }
  }

  throw new Error("No image was generated by the model.");
};

// This new function extracts lore from a narrative text.
export const extractLoreFromNarrative = async (narrative: string, history: Content[]): Promise<LoreEntry[]> => {
  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: [
        ...history,
        { role: 'user', parts: [{ text: `Here is the latest narrative chapter:\n\n---\n${narrative}\n---\n\nFrom the text above, extract the key lore terms and their descriptions.` }] }
      ],
      config: {
        systemInstruction: LORE_EXTRACTION_SYSTEM_INSTRUCTION,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.ARRAY,
          items: {
            type: Type.OBJECT,
            properties: {
              term: {
                type: Type.STRING,
                description: 'The key term, concept, or proper noun.',
              },
              description: {
                type: Type.STRING,
                description: 'A brief, in-universe description of the term.',
              },
            },
            required: ['term', 'description'],
          },
        },
      },
    });

    const jsonStr = response.text.trim();
    if (!jsonStr) {
      return [];
    }
    
    const loreData = JSON.parse(jsonStr);
    return loreData as LoreEntry[];
  } catch (e: any) {
    console.error("Failed to parse or fetch lore JSON:", e);
    // Check if the error message indicates a rate limit issue from the API.
    const errorMessage = typeof e === 'string' ? e : e?.message || '';
    if (errorMessage.includes('RESOURCE_EXHAUSTED') || errorMessage.includes('429')) {
      throw new RateLimitError("Lore extraction failed due to API rate limits.");
    }
    return []; // Return empty array on other failures
  }
};